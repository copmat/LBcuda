#include "defines.h"

  module kernels_fluid_bc
    use dimensions_m
    use kernels_fluid 
    implicit none

    private :: compute_rho

  contains
   
    attributes(device) function compute_rho(pops, i,j,k, flip)
     integer, intent(in) :: i,j,k, flip
     real, intent(in) :: pops(0:nx+1,0:ny+1,0:nz+1, 0:npops-1, 2)
     real :: compute_rho

     compute_rho = pops(i,j,k,0, flip) + pops(i,j,k,1, flip) + pops(i,j,k,2, flip) + &
       pops(i,j,k,3, flip) + pops(i,j,k,4, flip) + &
       pops(i,j,k,5, flip) + pops(i,j,k,6, flip) + pops(i,j,k,7, flip) + &
       pops(i,j,k,8, flip) + pops(i,j,k,9, flip) + &
       pops(i,j,k,10, flip) + pops(i,j,k,11, flip) + pops(i,j,k,12, flip) + &
       pops(i,j,k,13, flip) + pops(i,j,k,14, flip) + &
       pops(i,j,k,15, flip) + pops(i,j,k,16, flip) + &
       pops(i,j,k,17, flip) + pops(i,j,k,18, flip)
    end function compute_rho

    attributes(device) pure function pimage(i, nMax)
      integer, intent(in) :: i, nMax
      integer :: pimage

      pimage = mod(i +nMax-1, nMax) + 1
    end function


    attributes(device) pure function pbc_images_centeredx(x, atomx)
      real, intent(in) :: x, atomx
      real :: pbc_images_centeredx, xxs, aaa

      xxs = x - atomx
      aaa = ONE/real(nx)

      pbc_images_centeredx = xxs - real(nx)*nint(aaa*xxs) + atomx
    end function

    attributes(device) pure function pbc_images_centeredy(y, atomy)
      real, intent(in) :: y, atomy
      real :: pbc_images_centeredy, yys, bbb

      yys = y - atomy
      bbb = ONE/real(ny)

      pbc_images_centeredy = yys - real(ny)*nint(bbb*yys) + atomy
    end function

    attributes(device) pure function pbc_images_centeredz(z, atomz)
      real, intent(in) :: z, atomz
      real :: pbc_images_centeredz, zzs, ccc

      zzs = z - atomz
      ccc = ONE/real(nz)

      pbc_images_centeredz = zzs - real(nz)*nint(ccc*zzs) + atomz
    end function

    ! Periodic BC 	-----------------------------------------------
    attributes(global) subroutine bc_per_x(step, flip)
      integer, value :: step,flip
      integer :: j,k !, l
  
      j = (blockIdx%x-1) * TILE_DIM + threadIdx%x - 1
      k = (blockIdx%y-1) * TILE_DIM + threadIdx%y - 1
      ! if (1==step .and. 1==j*k) write(*,*) 'CUDA bc_per_x] i,j:',j,k

      ! Apply BC also on virtual nodes...
      if (j<=ny+1 .and. k<=nz+1) then
        popsR_d(1, j,k, 1, flip) = popsR_d(nx+1,j,k, 1, flip)
        popsR_d(1, j,k, 7, flip) = popsR_d(nx+1,j,k, 7, flip)
        popsR_d(1, j,k,10, flip) = popsR_d(nx+1,j,k,10, flip)
        popsR_d(1, j,k,11, flip) = popsR_d(nx+1,j,k,11, flip)
        popsR_d(1, j,k,14, flip) = popsR_d(nx+1,j,k,14, flip)

        popsR_d(nx,j,k, 2, flip) = popsR_d(0,j,k, 2, flip)
        popsR_d(nx,j,k, 8, flip) = popsR_d(0,j,k, 8, flip)
        popsR_d(nx,j,k, 9, flip) = popsR_d(0,j,k, 9, flip)
        popsR_d(nx,j,k,12, flip) = popsR_d(0,j,k,12, flip)
        popsR_d(nx,j,k,13, flip) = popsR_d(0,j,k,13, flip)

        ! do l = 1, npops-1
        !      if (ex_d(l)>0) then
        !       if (1==step .and. 1==j*k) write(*,*) 'CUDA bc_per_x] 1<-nx+1 l',l
        !       popsR_d(1, j,k, l, flip) = popsR_d(nx+1,j,k, l, flip)
        !      endif
        !      if (ex_d(l)<0) then
        !       if (1==step .and. 1==j*k) write(*,*) 'CUDA bc_per_x] nx<-0 l',l
        !       popsR_d(nx,j,k, l, flip) = popsR_d(0,j,k, l, flip)
        !      endif
        ! end do
      endif
    end subroutine bc_per_x


    attributes(global) subroutine bc_per_y(step, flip)
      integer, value :: step,flip
      integer :: i,k, l
  
      i = (blockIdx%x-1) * TILE_DIM + threadIdx%x - 1
      k = (blockIdx%y-1) * TILE_DIM + threadIdx%y - 1
      ! if (1==step .and. 1==i*k) write(*,*) 'CUDA bc_per_y] i,k:',i,k

      if (0<=i .and. i<=nx+1 .and. 0<=k .and. k<=nz+1) then
        do l = 1, npops-1
             if (ey_d(l)>0) popsR_d(i,1,k, l, flip) = popsR_d(i,ny+1,k, l, flip)
             if (ey_d(l)<0) popsR_d(i,ny,k, l, flip) = popsR_d(i,0,k, l, flip)
        end do
      endif
    end subroutine bc_per_y


    attributes(global) subroutine bc_per_z(step, flip)
      integer, value :: step,flip
      integer :: i,j, l
  
      i = (blockIdx%x-1) * TILE_DIM + threadIdx%x - 1
      j = (blockIdx%y-1) * TILE_DIM + threadIdx%y - 1
      ! if (1==step .and. 1==i*j) write(*,*) 'CUDA bc_per_z] i,j:',i,j

      if (0<=j .and. j<=ny+1 .and. 0<=i .and. i<=nx+1) then
        do l = 1, npops-1
             if (ez_d(l)>0) popsR_d(i,j,1, l, flip) = popsR_d(i,j,nz+1, l, flip)
             if (ez_d(l)<0) popsR_d(i,j,nz, l, flip) = popsR_d(i,j,0, l, flip)
        end do
      endif
    end subroutine bc_per_z

    ! Periodic BC 	2 fluids ----------------------------------------------
    attributes(global) subroutine bc_per_x2(step, flip, faiPops,faiRho)
      integer, value :: step,flip
      logical, value :: faiPops, faiRho
      integer :: j,k, l
  
      j = (blockIdx%x-1) * TILE_DIM + threadIdx%x - 1
      k = (blockIdx%y-1) * TILE_DIM + threadIdx%y - 1
      ! if (1==step .and. 1==j*k) write(*,*) 'CUDA bc_per_x2] i,j:',j,k

      if (1<=j .and. j<=ny .and. 1<=k .and. k<=nz) then
        if (faiPops) then
          do l = 1, npops-1
            popsR_d(nx+1, j,k, l, flip) = popsR_d(1,j,k, l, flip)
            popsB_d(nx+1, j,k, l, flip) = popsB_d(1,j,k, l, flip)
          
            popsR_d(0,j,k, l, flip) = popsR_d(nx,j,k, l, flip)
            popsB_d(0,j,k, l, flip) = popsB_d(nx,j,k, l, flip)
          end do
        endif

        if (faiRho) then
          rhoR_d (nx+1,j,k) = rhoR_d (1,j,k)
          rhoB_d (nx+1,j,k) = rhoB_d (1,j,k)

          rhoR_d (0,j,k) = rhoR_d (nx,j,k)
          rhoB_d (0,j,k) = rhoB_d (nx,j,k)
        endif
      endif
    end subroutine bc_per_x2


    attributes(global) subroutine bc_per_y2(step, flip, faiPops,faiRho)
      integer, value :: step,flip
      logical, value :: faiPops, faiRho
      integer :: i,k, l
  
      i = (blockIdx%x-1) * TILE_DIM + threadIdx%x - 1
      k = (blockIdx%y-1) * TILE_DIM + threadIdx%y - 1
      ! if (1==step .and. 1==i*k) write(*,*) 'CUDA bc_per_y2] i,k:',i,k

      if (1<=i .and. i<=nx .and. 1<=k .and. k<=nz) then
        if (faiPops) then
          do l = 1, npops-1
            popsR_d(i,ny+1,k, l, flip) = popsR_d(i,1,k, l, flip)
            popsB_d(i,ny+1,k, l, flip) = popsB_d(i,1,k, l, flip)
          
            popsR_d(i,0,k, l, flip) = popsR_d(i,ny,k, l, flip)
            popsB_d(i,0,k, l, flip) = popsB_d(i,ny,k, l, flip)
          end do
        endif

        if (faiRho) then
          rhoR_d(i,ny+1,k) = rhoR_d(i,1,k)
          rhoB_d(i,ny+1,k) = rhoB_d(i,1,k)

          rhoR_d(i,0,k) = rhoR_d(i,ny,k)
          rhoB_d(i,0,k) = rhoB_d(i,ny,k)
        endif
      endif
    end subroutine bc_per_y2


    attributes(global) subroutine bc_per_z2(step, flip, faiPops,faiRho)
      integer, value :: step,flip
      logical, value :: faiPops, faiRho
      integer :: i,j, l
  
      i = (blockIdx%x-1) * TILE_DIM + threadIdx%x - 1
      j = (blockIdx%y-1) * TILE_DIM + threadIdx%y - 1
      ! if (1==step .and. 1==i*j) write(*,*) 'CUDA bc_per_z2] i,j:',i,j

      if (1<=j .and. j<=ny .and. 1<=i .and. i<=nx) then
        if (faiPops) then
          do l = 1, npops-1        
            popsR_d(i,j,nz+1, l, flip) = popsR_d(i,j,1, l, flip)
            popsB_d(i,j,nz+1, l, flip) = popsB_d(i,j,1, l, flip)
          
            popsR_d(i,j,0, l, flip) = popsR_d(i,j,nz, l, flip)
            popsB_d(i,j,0, l, flip) = popsB_d(i,j,nz, l, flip)
          end do
        endif

        if (faiRho) then
          rhoR_d(i,j,nz+1) = rhoR_d(i,j,1)
          rhoB_d(i,j,nz+1) = rhoB_d(i,j,1)

          rhoR_d(i,j,0) = rhoR_d(i,j,nz)
          rhoB_d(i,j,0) = rhoB_d(i,j,nz)
        endif
      endif
    end subroutine bc_per_z2


    attributes(global) subroutine bc_edge_z2(step, flip, faiPops,faiRho)
      integer, value :: step,flip
      logical, value :: faiPops, faiRho
      integer :: k, l
  
      k = (blockIdx%x-1) * TILE_DIM + threadIdx%x - 1

      if (1<=k .and. k<=nz) then
        if (faiPops) then
          do l = 1, npops-1
            popsR_d(0,0,k, l, flip) = popsR_d(nx,ny,k, l, flip)
            popsB_d(0,0,k, l, flip) = popsB_d(nx,ny,k, l, flip)

            popsR_d(0,ny+1,k, l, flip) = popsR_d(nx,1,k, l, flip)
            popsB_d(0,ny+1,k, l, flip) = popsB_d(nx,1,k, l, flip)

            popsR_d(nx+1,0,k, l, flip) = popsR_d(1,ny,k, l, flip)
            popsB_d(nx+1,0,k, l, flip) = popsB_d(1,ny,k, l, flip)

            popsR_d(nx+1,ny+1,k, l, flip) = popsR_d(1,1,k, l, flip)
            popsB_d(nx+1,ny+1,k, l, flip) = popsB_d(1,1,k, l, flip)
          end do
        endif

        if (faiRho) then
          rhoR_d (0,0,k) = rhoR_d (nx,ny,k)
          rhoB_d (0,0,k) = rhoB_d (nx,ny,k)

          rhoR_d (0,ny+1,k) = rhoR_d (nx,1,k)
          rhoB_d (0,ny+1,k) = rhoB_d (nx,1,k)

          rhoR_d (nx+1,0,k) = rhoR_d (1,ny,k)
          rhoB_d (nx+1,0,k) = rhoB_d (1,ny,k)

          rhoR_d (nx+1,ny+1,k) = rhoR_d (1,1,k)
          rhoB_d (nx+1,ny+1,k) = rhoB_d (1,1,k)
        endif
      endif
    end subroutine bc_edge_z2

    attributes(global) subroutine bc_edge_y2(step, flip, faiPops,faiRho)
      integer, value :: step,flip
      logical, value :: faiPops, faiRho
      integer :: j, l
  
      j = (blockIdx%x-1) * TILE_DIM + threadIdx%x - 1

      if (1<=j .and. j<=ny) then
        if (faiPops) then
          do l = 1, npops-1
            popsR_d(0,j,0, l, flip) = popsR_d(nx,j,nz, l, flip)
            popsB_d(0,j,0, l, flip) = popsB_d(nx,j,nz, l, flip)

            popsR_d(0,j,nz+1, l, flip) = popsR_d(nx,j,1, l, flip)
            popsB_d(0,j,nz+1, l, flip) = popsB_d(nx,j,1, l, flip)

            popsR_d(nx+1,j,0, l, flip) = popsR_d(1,j,nz, l, flip)
            popsB_d(nx+1,j,0, l, flip) = popsB_d(1,j,nz, l, flip)

            popsR_d(nx+1,j,nz+1, l, flip) = popsR_d(1,j,1, l, flip)
            popsB_d(nx+1,j,nz+1, l, flip) = popsB_d(1,j,1, l, flip)
          end do
        endif

        if (faiRho) then
          rhoR_d (0,j,0) = rhoR_d (nx,j,nz)
          rhoB_d (0,j,0) = rhoB_d (nx,j,nz)

          rhoR_d (0,j,nz+1) = rhoR_d (nx,j,1)
          rhoB_d (0,j,nz+1) = rhoB_d (nx,j,1)

          rhoR_d (nx+1,j,0) = rhoR_d (1,j,nz)
          rhoB_d (nx+1,j,0) = rhoB_d (1,j,nz)

          rhoR_d (nx+1,j,nz+1) = rhoR_d (1,j,1)
          rhoB_d (nx+1,j,nz+1) = rhoB_d (1,j,1)
        endif
      endif
    end subroutine bc_edge_y2

    attributes(global) subroutine bc_edge_x2(step, flip, faiPops,faiRho)
      integer, value :: step,flip
      logical, value :: faiPops, faiRho
      integer :: i, l
  
      i = (blockIdx%x-1) * TILE_DIM + threadIdx%x - 1

      if (1<=i .and. i<=nx) then
        if (faiPops) then
          do l = 1, npops-1
            popsR_d(i,0,0, l, flip) = popsR_d(i,ny,nz, l, flip)
            popsB_d(i,0,0, l, flip) = popsB_d(i,ny,nz, l, flip)

            popsR_d(i,0,nz+1, l, flip) = popsR_d(i,ny,1, l, flip)
            popsB_d(i,0,nz+1, l, flip) = popsB_d(i,ny,1, l, flip)

            popsR_d(i,ny+1,0, l, flip) = popsR_d(i,1,nz, l, flip)
            popsB_d(i,ny+1,0, l, flip) = popsB_d(i,1,nz, l, flip)

            popsR_d(i,ny+1,nz+1, l, flip) = popsR_d(i,1,1, l, flip)
            popsB_d(i,ny+1,nz+1, l, flip) = popsB_d(i,1,1, l, flip)
          end do
        endif

        if (faiRho) then
          rhoR_d (i,0,0) = rhoR_d (i,ny,nz)
          rhoB_d (i,0,0) = rhoB_d (i,ny,nz)

          rhoR_d (i,0,nz+1) = rhoR_d (i,ny,1)
          rhoB_d (i,0,nz+1) = rhoB_d (i,ny,1)

          rhoR_d (i,ny+1,0) = rhoR_d (i,1,nz)
          rhoB_d (i,ny+1,0) = rhoB_d (i,1,nz)

          rhoR_d (i,ny+1,nz+1) = rhoR_d (i,1,1)
          rhoB_d (i,ny+1,nz+1) = rhoB_d (i,1,1)
        endif
      endif
    end subroutine bc_edge_x2


    attributes(global) subroutine bc_corners(step, flip)
      integer, value :: step,flip
      integer :: j,k, l
  
      j = (blockIdx%x-1) * TILE_DIM + threadIdx%x - 1
      k = (blockIdx%y-1) * TILE_DIM + threadIdx%y - 1
    end subroutine bc_corners

    !!! Periodic treat myfluid
    attributes(global) subroutine isfluid_per_x2(step, flip)
      integer, value :: step,flip
      integer :: j,k, l
  
      j = (blockIdx%x-1) * TILE_DIM + threadIdx%x - 1
      k = (blockIdx%y-1) * TILE_DIM + threadIdx%y - 1

      if (1<=j .and. j<=ny .and. 1<=k .and. k<=nz) then
        myfluid_d(nx+1, j,k, flip) = myfluid_d( 1,j,k, flip)
        myfluid_d(   0, j,k, flip) = myfluid_d(nx,j,k, flip)
      endif
    end subroutine isfluid_per_x2


    attributes(global) subroutine isfluid_per_y2(step, flip)
      integer, value :: step,flip
      integer :: i,k, l
  
      i = (blockIdx%x-1) * TILE_DIM + threadIdx%x - 1
      k = (blockIdx%y-1) * TILE_DIM + threadIdx%y - 1

      if (1<=i .and. i<=nx .and. 1<=k .and. k<=nz) then
        myfluid_d(i,ny+1,k, flip) = myfluid_d(i, 1,k, flip)
        myfluid_d(i,   0,k, flip) = myfluid_d(i,ny,k, flip)
      endif
    end subroutine isfluid_per_y2


    attributes(global) subroutine isfluid_per_z2(step, flip)
      integer, value :: step,flip
      integer :: i,j, l
  
      i = (blockIdx%x-1) * TILE_DIM + threadIdx%x - 1
      j = (blockIdx%y-1) * TILE_DIM + threadIdx%y - 1

      if (1<=j .and. j<=ny .and. 1<=i .and. i<=nx) then
        myfluid_d(i,j,nz+1, flip) = myfluid_d(i,j, 1, flip)        
        myfluid_d(i,j,   0, flip) = myfluid_d(i,j,nz, flip)
      endif
    end subroutine isfluid_per_z2


    attributes(global) subroutine isfluid_edge_z2(step, flip)
      integer, value :: step,flip
      integer :: k, l
  
      k = (blockIdx%x-1) * TILE_DIM + threadIdx%x - 1

      if (1<=k .and. k<=nz) then
        myfluid_d (   0,   0,k, flip) = myfluid_d (nx,ny,k, flip)
        myfluid_d (   0,ny+1,k, flip) = myfluid_d (nx, 1,k, flip)
        myfluid_d (nx+1,   0,k, flip) = myfluid_d ( 1,ny,k, flip)
        myfluid_d (nx+1,ny+1,k, flip) = myfluid_d ( 1, 1,k, flip)
      endif
    end subroutine isfluid_edge_z2

    attributes(global) subroutine isfluid_edge_y2(step, flip)
      integer, value :: step,flip
      integer :: j, l
  
      j = (blockIdx%x-1) * TILE_DIM + threadIdx%x - 1

      if (1<=j .and. j<=ny) then
        myfluid_d (   0,j,   0, flip) = myfluid_d (nx,j, nz, flip)
        myfluid_d (   0,j,nz+1, flip) = myfluid_d (nx,j,  1, flip)
        myfluid_d (nx+1,j,   0, flip) = myfluid_d ( 1,j, nz, flip)
        myfluid_d (nx+1,j,nz+1, flip) = myfluid_d ( 1,j,  1, flip)
      endif
    end subroutine isfluid_edge_y2

    attributes(global) subroutine isfluid_edge_x2(step, flip)
      integer, value :: step,flip
      integer :: i, l
  
      i = (blockIdx%x-1) * TILE_DIM + threadIdx%x - 1

      if (1<=i .and. i<=nx) then
        myfluid_d (i,   0,   0, flip) = myfluid_d (i,ny,nz, flip)
        myfluid_d (i,   0,nz+1, flip) = myfluid_d (i,ny, 1, flip)
        myfluid_d (i,ny+1,   0, flip) = myfluid_d (i, 1,nz, flip)
        myfluid_d (i,ny+1,nz+1, flip) = myfluid_d (i, 1, 1, flip)
      endif
    end subroutine isfluid_edge_x2


    attributes(global) subroutine bc_periodic_ext_x(step, flip)
      integer, value :: step,flip
      integer :: j,k, l
  
      j = (blockIdx%x-1) * TILE_DIM + threadIdx%x - 1
      k = (blockIdx%y-1) * TILE_DIM + threadIdx%y - 1
      ! if (1==step .and. 1==j*k) write(*,*) 'CUDA bc_periodic_ext_x] i,j:',j,k

      ! Copy on virtual nodes...
      if (0<=j .and. j<=ny+1 .and. 0<=k .and. k<=nz+1) then
        do l = 0, npops-1
          popsR_d(0   ,j,k, l, flip) = popsR_d(nx,j,k, l, flip)
          popsR_d(nx+1,j,k, l, flip) = popsR_d(1 ,j,k, l, flip)
        end do
      endif
    end subroutine bc_periodic_ext_x

    attributes(global) subroutine bc_periodic_ext_y(step, flip)
      integer, value :: step,flip
      integer :: i,k, l
  
      i = (blockIdx%x-1) * TILE_DIM + threadIdx%x - 1
      k = (blockIdx%y-1) * TILE_DIM + threadIdx%y - 1
      ! if (1==step .and. 1==i*k) write(*,*) 'CUDA bc_periodic_ext_y] i,k:',i,k

      if (0<=i .and. i<=nx+1 .and. 0<=k .and. k<=nz+1) then
        do l = 0, npops-1
          popsR_d(i,0   ,k, l, flip) = popsR_d(i,ny,k, l, flip)
          popsR_d(i,ny+1,k, l, flip) = popsR_d(i,1 ,k, l, flip)
        end do
      endif
    end subroutine bc_periodic_ext_y

    attributes(global) subroutine bc_periodic_ext_z(step, flip)
      integer, value :: step,flip
      integer :: i,j, l
  
      i = (blockIdx%x-1) * TILE_DIM + threadIdx%x - 1
      j = (blockIdx%y-1) * TILE_DIM + threadIdx%y - 1
      ! if (1==step .and. 1==i*j) write(*,*) 'CUDA bc_periodic_ext_z] i,j:',i,j

      if (0<=j .and. j<=ny+1 .and. 0<=i .and. i<=nx+1) then
        do l = 0, npops-1
          popsR_d(i,j,0   , l, flip) = popsR_d(i,j,nz, l, flip)
          popsR_d(i,j,nz+1, l, flip) = popsR_d(i,j,1 , l, flip)
        end do
      endif
    end subroutine bc_periodic_ext_z


    ! Bounce-Back BC
    attributes(global) subroutine bc_bb_x(step, flip)
      real :: rho1,rho2
      integer, value :: step,flip
      integer :: j,k
  
      j = (blockIdx%x-1) * TILE_DIM + threadIdx%x
      k = (blockIdx%y-1) * TILE_DIM + threadIdx%y
      ! if (1==step .and. 1==j*k) write(*,*) 'CUDA bc_bb_x] j,k:',j,k

      if (0<=j .and. j<=ny+1 .and. 0<=k .and. k<=nz+1) then
	      rho1 = compute_rho(popsR_d,1,j,k,flip)

        popsR_d(1,j,k, 1, flip) = popsR_d(0, j,   k,    2, flip)
        popsR_d(1,j,k, 7, flip) = popsR_d(0, j-1, k,    8, flip)
        popsR_d(1,j,k,10, flip) = popsR_d(0, j+1, k,    9, flip)
        popsR_d(1,j,k,11, flip) = popsR_d(0, j  , k-1, 12, flip)
        popsR_d(1,j,k,14, flip) = popsR_d(0, j  , k+1, 13, flip)

	      rho2 = compute_rho(popsR_d,nx,j,k,flip)

        popsR_d(nx,j,k, 2, flip) = popsR_d(nx+1, j,   k,    1, flip)
        popsR_d(nx,j,k, 8, flip) = popsR_d(nx+1, j+1, k,    7, flip)
        popsR_d(nx,j,k, 9, flip) = popsR_d(nx+1, j-1, k,   10, flip)
        popsR_d(nx,j,k,12, flip) = popsR_d(nx+1, j,   k+1, 11, flip)
        popsR_d(nx,j,k,13, flip) = popsR_d(nx+1, j,   k-1, 14, flip)
      endif
    end subroutine bc_bb_x


    attributes(global) subroutine bc_bb_y(step, flip)
      real :: rho1,rho2
      integer, value :: step,flip
      integer :: i,k
  
      i = (blockIdx%x-1) * TILE_DIM + threadIdx%x
      k = (blockIdx%y-1) * TILE_DIM + threadIdx%y
      ! if (1==step .and. 1==i*k) write(*,*) 'CUDA bc_bb_y] i,k:',i,k

      if (0<=i .and. i<=nx+1 .and. 0<=k .and. k<=nz+1) then
          popsR_d(i,1,k, 3, flip) = popsR_d(i,   0, k,    4, flip)
          popsR_d(i,1,k, 7, flip) = popsR_d(i-1, 0, k,    8, flip)
          popsR_d(i,1,k, 9, flip) = popsR_d(i+1, 0, k,   10, flip)
          popsR_d(i,1,k,15, flip) = popsR_d(i,   0, k-1, 16, flip)
          popsR_d(i,1,k,18, flip) = popsR_d(i,   0, k+1, 17, flip)

          popsR_d(i,ny,k, 4, flip) = popsR_d(i,   ny+1, k,    3, flip)
          popsR_d(i,ny,k, 8, flip) = popsR_d(i+1, ny+1, k,    7, flip)
          popsR_d(i,ny,k,10, flip) = popsR_d(i-1, ny+1, k,    9, flip)
          popsR_d(i,ny,k,16, flip) = popsR_d(i,   ny+1, k+1, 15, flip)
          popsR_d(i,ny,k,17, flip) = popsR_d(i,   ny+1, k-1, 18, flip)
      endif
    end subroutine bc_bb_y


    attributes(global) subroutine bc_bb_z(step, flip)
      real :: rho1,rho2
      integer, value :: step,flip
      integer :: i,j
  
      i = (blockIdx%x-1) * TILE_DIM + threadIdx%x
      j = (blockIdx%y-1) * TILE_DIM + threadIdx%y
      ! if (1==step .and. 1==i*j) write(*,*) 'CUDA bc_bb_z] i,j:',i,j

      if (0<=j .and. j<=ny+1 .and. 0<=i .and. i<=nx+1) then
        rho1 = compute_rho(popsR_d,i,j,1,flip)

        popsR_d(i,j,1, 5, flip) = popsR_d(i,   j,   0,  6, flip)
        popsR_d(i,j,1,11, flip) = popsR_d(i-1, j,   0, 12, flip) + p_d(12)*buz_d*rho1 * wall_z0_d(1)
        popsR_d(i,j,1,13, flip) = popsR_d(i+1, j,   0, 14, flip) - p_d(14)*buz_d*rho1 * wall_z0_d(1)
        popsR_d(i,j,1,15, flip) = popsR_d(i,   j-1, 0, 16, flip)
        popsR_d(i,j,1,17, flip) = popsR_d(i,   j+1, 0, 18, flip)

        rho2 = compute_rho(popsR_d,i,j,nz,flip)

        popsR_d(i,j,nz, 6, flip) = popsR_d(i,   j,   nz+1,  5, flip)
        popsR_d(i,j,nz,12, flip) = popsR_d(i+1, j,   nz+1, 11, flip) - p_d(11)*buz_d*rho2 * wall_z1_d(1)
        popsR_d(i,j,nz,14, flip) = popsR_d(i-1, j,   nz+1, 13, flip) + p_d(13)*buz_d*rho2 * wall_z1_d(1)
        popsR_d(i,j,nz,16, flip) = popsR_d(i,   j+1, nz+1, 15, flip)
        popsR_d(i,j,nz,18, flip) = popsR_d(i,   j-1, nz+1, 17, flip)
      endif
    end subroutine bc_bb_z

    ! Bounce-Back BC 2 fluids
    attributes(global) subroutine bc_bb_x2(step, flip)
      integer, value :: step,flip
      integer :: j,k
  
      j = (blockIdx%x-1) * TILE_DIM + threadIdx%x
      k = (blockIdx%y-1) * TILE_DIM + threadIdx%y
      ! if (1==step .and. 1==j*k) write(*,*) 'CUDA bc_bb_x] j,k:',j,k

      if (0<=j .and. j<=ny+1 .and. 0<=k .and. k<=nz+1) then	    
        popsR_d(1,j,k, 1, flip) = popsR_d(0, j,   k,    2, flip)
        popsR_d(1,j,k, 7, flip) = popsR_d(0, j-1, k,    8, flip)
        popsR_d(1,j,k,10, flip) = popsR_d(0, j+1, k,    9, flip)
        popsR_d(1,j,k,11, flip) = popsR_d(0, j  , k-1, 12, flip)
        popsR_d(1,j,k,14, flip) = popsR_d(0, j  , k+1, 13, flip)

        popsR_d(nx,j,k, 2, flip) = popsR_d(nx+1, j,   k,    1, flip)
        popsR_d(nx,j,k, 8, flip) = popsR_d(nx+1, j+1, k,    7, flip)
        popsR_d(nx,j,k, 9, flip) = popsR_d(nx+1, j-1, k,   10, flip)
        popsR_d(nx,j,k,12, flip) = popsR_d(nx+1, j,   k+1, 11, flip)
        popsR_d(nx,j,k,13, flip) = popsR_d(nx+1, j,   k-1, 14, flip)

        popsB_d(1,j,k, 1, flip) = popsB_d(0, j,   k,    2, flip)
        popsB_d(1,j,k, 7, flip) = popsB_d(0, j-1, k,    8, flip)
        popsB_d(1,j,k,10, flip) = popsB_d(0, j+1, k,    9, flip)
        popsB_d(1,j,k,11, flip) = popsB_d(0, j  , k-1, 12, flip)
        popsB_d(1,j,k,14, flip) = popsB_d(0, j  , k+1, 13, flip)

        popsB_d(nx,j,k, 2, flip) = popsB_d(nx+1, j,   k,    1, flip)
        popsB_d(nx,j,k, 8, flip) = popsB_d(nx+1, j+1, k,    7, flip)
        popsB_d(nx,j,k, 9, flip) = popsB_d(nx+1, j-1, k,   10, flip)
        popsB_d(nx,j,k,12, flip) = popsB_d(nx+1, j,   k+1, 11, flip)
        popsB_d(nx,j,k,13, flip) = popsB_d(nx+1, j,   k-1, 14, flip)
      endif
    end subroutine bc_bb_x2


    attributes(global) subroutine bc_bb_y2(step, flip)
      integer, value :: step,flip
      integer :: i,k
  
      i = (blockIdx%x-1) * TILE_DIM + threadIdx%x
      k = (blockIdx%y-1) * TILE_DIM + threadIdx%y
      ! if (1==step .and. 1==i*k) write(*,*) 'CUDA bc_bb_y] i,k:',i,k

      if (0<=i .and. i<=nx+1 .and. 0<=k .and. k<=nz+1) then
          popsR_d(i,1,k, 3, flip) = popsR_d(i,   0, k,    4, flip)
          popsR_d(i,1,k, 7, flip) = popsR_d(i-1, 0, k,    8, flip)
          popsR_d(i,1,k, 9, flip) = popsR_d(i+1, 0, k,   10, flip)
          popsR_d(i,1,k,15, flip) = popsR_d(i,   0, k-1, 16, flip)
          popsR_d(i,1,k,18, flip) = popsR_d(i,   0, k+1, 17, flip)

          popsR_d(i,ny,k, 4, flip) = popsR_d(i,   ny+1, k,    3, flip)
          popsR_d(i,ny,k, 8, flip) = popsR_d(i+1, ny+1, k,    7, flip)
          popsR_d(i,ny,k,10, flip) = popsR_d(i-1, ny+1, k,    9, flip)
          popsR_d(i,ny,k,16, flip) = popsR_d(i,   ny+1, k+1, 15, flip)
          popsR_d(i,ny,k,17, flip) = popsR_d(i,   ny+1, k-1, 18, flip)

          popsB_d(i,1,k, 3, flip) = popsB_d(i,   0, k,    4, flip)
          popsB_d(i,1,k, 7, flip) = popsB_d(i-1, 0, k,    8, flip)
          popsB_d(i,1,k, 9, flip) = popsB_d(i+1, 0, k,   10, flip)
          popsB_d(i,1,k,15, flip) = popsB_d(i,   0, k-1, 16, flip)
          popsB_d(i,1,k,18, flip) = popsB_d(i,   0, k+1, 17, flip)

          popsB_d(i,ny,k, 4, flip) = popsB_d(i,   ny+1, k,    3, flip)
          popsB_d(i,ny,k, 8, flip) = popsB_d(i+1, ny+1, k,    7, flip)
          popsB_d(i,ny,k,10, flip) = popsB_d(i-1, ny+1, k,    9, flip)
          popsB_d(i,ny,k,16, flip) = popsB_d(i,   ny+1, k+1, 15, flip)
          popsB_d(i,ny,k,17, flip) = popsB_d(i,   ny+1, k-1, 18, flip)
      endif
    end subroutine bc_bb_y2


    attributes(global) subroutine bc_bb_z2(step, flip)
      real :: rho1,rho2, rho3,rho4
      integer, value :: step,flip
      integer :: i,j
  
      i = (blockIdx%x-1) * TILE_DIM + threadIdx%x
      j = (blockIdx%y-1) * TILE_DIM + threadIdx%y
      ! if (1==step .and. 1==i*j) write(*,*) 'CUDA bc_bb_z] i,j:',i,j

      if (0<=j .and. j<=ny+1 .and. 0<=i .and. i<=nx+1) then
        rho1 = compute_rho(popsR_d,i,j,1,flip)
        popsR_d(i,j,1, 5, flip) = popsR_d(i,   j,   0,  6, flip)
        popsR_d(i,j,1,11, flip) = popsR_d(i-1, j,   0, 12, flip) + p_d(12)*buz_d*rho1 * wall_z0_d(1)
        popsR_d(i,j,1,13, flip) = popsR_d(i+1, j,   0, 14, flip) - p_d(14)*buz_d*rho1 * wall_z0_d(1)
        popsR_d(i,j,1,15, flip) = popsR_d(i,   j-1, 0, 16, flip)
        popsR_d(i,j,1,17, flip) = popsR_d(i,   j+1, 0, 18, flip)

        rho2 = compute_rho(popsR_d,i,j,nz,flip)
        popsR_d(i,j,nz, 6, flip) = popsR_d(i,   j,   nz+1,  5, flip)
        popsR_d(i,j,nz,12, flip) = popsR_d(i+1, j,   nz+1, 11, flip) - p_d(11)*buz_d*rho2 * wall_z1_d(1)
        popsR_d(i,j,nz,14, flip) = popsR_d(i-1, j,   nz+1, 13, flip) + p_d(13)*buz_d*rho2 * wall_z1_d(1)
        popsR_d(i,j,nz,16, flip) = popsR_d(i,   j+1, nz+1, 15, flip)
        popsR_d(i,j,nz,18, flip) = popsR_d(i,   j-1, nz+1, 17, flip)

        rho3 = compute_rho(popsB_d,i,j,1,flip)
        popsB_d(i,j,1, 5, flip) = popsB_d(i,   j,   0,  6, flip)
        popsB_d(i,j,1,11, flip) = popsB_d(i-1, j,   0, 12, flip) + p_d(12)*buz_d*rho3 * wall_z0_d(1)
        popsB_d(i,j,1,13, flip) = popsB_d(i+1, j,   0, 14, flip) - p_d(14)*buz_d*rho3 * wall_z0_d(1)
        popsB_d(i,j,1,15, flip) = popsB_d(i,   j-1, 0, 16, flip)
        popsB_d(i,j,1,17, flip) = popsB_d(i,   j+1, 0, 18, flip)

        rho4 = compute_rho(popsB_d,i,j,nz,flip)
        popsB_d(i,j,nz, 6, flip) = popsB_d(i,   j,   nz+1,  5, flip)
        popsB_d(i,j,nz,12, flip) = popsB_d(i+1, j,   nz+1, 11, flip) - p_d(11)*buz_d*rho4 * wall_z1_d(1)
        popsB_d(i,j,nz,14, flip) = popsB_d(i-1, j,   nz+1, 13, flip) + p_d(13)*buz_d*rho4 * wall_z1_d(1)
        popsB_d(i,j,nz,16, flip) = popsB_d(i,   j+1, nz+1, 15, flip)
        popsB_d(i,j,nz,18, flip) = popsB_d(i,   j-1, nz+1, 17, flip)
      endif
    end subroutine bc_bb_z2
  end module kernels_fluid_bc
