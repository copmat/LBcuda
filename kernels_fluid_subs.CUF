#include "defines.h"

  module kernels_fluid_subs
    use dimensions_m
    use kernels_fluid
    use kernels_fluid_bc 
    implicit none

    private :: compute_rho   
    private :: equil
    private :: compute_u_1fl,compute_v_1fl,compute_w_1fl
  contains
  
   attributes(device) function compute_rho(pops, i,j,k, flip)
     integer, intent(in) :: i,j,k, flip
     real, intent(in) :: pops(0:nx+1,0:ny+1,0:nz+1, 0:npops-1, 2)
     real :: compute_rho

     compute_rho = pops(i,j,k,0, flip) + pops(i,j,k,1, flip) + pops(i,j,k,2, flip) + &
       pops(i,j,k,3, flip) + pops(i,j,k,4, flip) + &
       pops(i,j,k,5, flip) + pops(i,j,k,6, flip) + pops(i,j,k,7, flip) + &
       pops(i,j,k,8, flip) + pops(i,j,k,9, flip) + &
       pops(i,j,k,10, flip) + pops(i,j,k,11, flip) + pops(i,j,k,12, flip) + &
       pops(i,j,k,13, flip) + pops(i,j,k,14, flip) + &
       pops(i,j,k,15, flip) + pops(i,j,k,16, flip) + &
       pops(i,j,k,17, flip) + pops(i,j,k,18, flip)
    end function compute_rho
  
    attributes(device) function equil(rho,u,v,w, l)
     real, intent(in) :: rho,u,v,w
     integer, intent(in) :: l
     real :: equil
     real :: uv

     uv = (1.0/cssq) * (u*ex_d(l) + v*ey_d(l) + w*ez_d(l))
     equil = rho * p_d(l)*(ONE+uv+HALF*(uv*uv)-(HALF/cssq) * (u*u + v*v + w*w))
    end function equil

!!!!!!!!!!!!! Helpers for recovering phys vars

    attributes(device) function compute_u_1fl(pops, i,j,k, flip, invrho)
     integer, intent(in) :: i,j,k, flip
     real, intent(in) :: pops(0:nx+1,0:ny+1,0:nz+1, 0:npops-1, 2), invrho
     real :: compute_u_1fl

     compute_u_1fl   = invrho * ( pops(i,j,k,1, flip) - pops(i,j,k,2, flip) + pops(i,j,k,7, flip) - &
       pops(i,j,k,8, flip) - pops(i,j,k,9, flip) + &
       pops(i,j,k,10, flip) + pops(i,j,k,11, flip) - pops(i,j,k,12, flip) - &
       pops(i,j,k,13, flip) + pops(i,j,k,14, flip) )
    end function compute_u_1fl

    attributes(device) function compute_v_1fl(pops, i,j,k, flip, invrho)
     integer, intent(in) :: i,j,k, flip
     real, intent(in) :: pops(0:nx+1,0:ny+1,0:nz+1, 0:npops-1, 2), invrho
     real :: compute_v_1fl

     compute_v_1fl    = invrho * ( pops(i,j,k,3, flip) - pops(i,j,k,4, flip) + pops(i,j,k,7, flip) - &
       pops(i,j,k,8, flip) + pops(i,j,k,9, flip) - &
       pops(i,j,k,10, flip) + pops(i,j,k,15, flip) - pops(i,j,k,16, flip) - &
       pops(i,j,k,17, flip) + pops(i,j,k,18, flip) )
    end function compute_v_1fl

    attributes(device) function compute_w_1fl(pops, i,j,k, flip, invrho)
     integer, intent(in) :: i,j,k, flip
     real, intent(in) :: pops(0:nx+1,0:ny+1,0:nz+1, 0:npops-1, 2), invrho
     real :: compute_w_1fl

     compute_w_1fl    = invrho * ( pops(i,j,k,5, flip) - pops(i,j,k,6, flip) + pops(i,j,k,11, flip) - &
       pops(i,j,k,12, flip) + pops(i,j,k,13, flip) - &
       pops(i,j,k,14, flip) + pops(i,j,k,15, flip) - pops(i,j,k,16, flip) + &
       pops(i,j,k,17, flip) - pops(i,j,k,18, flip) )

    end function compute_w_1fl
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!	 	END of Helpers for recovering phys vars


    ! Setup
    attributes(global) subroutine setup(vx,vy,vz)
      real, value :: vx,vy,vz
      integer :: i,j,k, l
      real    :: rho, u,v,w, eq, x,y,z
  
      i = (blockIdx%x-1) * TILE_DIMx + threadIdx%x
      j = (blockIdx%y-1) * TILE_DIMy + threadIdx%y
      k = (blockIdx%z-1) * TILE_DIMz + threadIdx%z

      ! if (k>nz/2) then
      !   rho = 1.01
      ! else
      !   rho = 0.99
      ! endif

      x = 3.14159265358979 / nx * i
      y = 3.14159265358979 / ny * j
      z = 3.14159265358979 / nz * k
      rho = 1 + 0.1*sin(x)*sin(x) * sin(y)*sin(y) * sin(z)*sin(z)

      u = vx
      v = vy
      w = vz
      ! write(*,*) 'CUDA setup',rho,i,j,k
  
      rhoR_d(i,j,k) = rho
      do l = 0, npops-1
        eq = equil(rho, u,v,w, l)
        popsR_d(i,j,k, l, 1) = eq
      end do

      myfluid_d(i,j,k, 1) = fluid_fluid
      myfluid_d(i,j,k, 2) = fluid_fluid
    end subroutine setup

    attributes(device) function fcut(r, r1, r2)
     real, intent(in) :: r, r1, r2
     real fcut

     if ( r <= r1 ) then
        fcut = ONE
     elseif ( r > r2 ) then
        fcut = ZERO
     else
        fcut = HALF * cos((r-r1)*Pi/(r2-r1)) + HALF
     endif
    end function fcut

    attributes(global) subroutine setup2(vx,vy,vz)

      real, value :: vx,vy,vz
      integer :: i,j,k, l
      integer :: gli,glj,glk
      real    :: rhoR,rhoB, u,v,w, eqR,eqB, distx,disty,distz, rdist,tempr
      real,parameter    :: radius = glz/8
  
      i = (blockIdx%x-1) * TILE_DIMx + threadIdx%x
      j = (blockIdx%y-1) * TILE_DIMy + threadIdx%y
      k = (blockIdx%z-1) * TILE_DIMz + threadIdx%z
      if (1==i*j*k) write(*,*) 'CUDA setup2] offset:', offset_d(1),offset_d(2),offset_d(3)

      gli = i + offset_d(1)
      glj = j + offset_d(2)
      glk = k + offset_d(3)

      if (1==i*j*k) write(*,*) 'CUDA setup2] offset:', gli, glj, glk

      distx = gli - (glx/2 + 0.5)
      disty = glj - (gly/2 + 0.5)
      distz = glk - (glz/4 + 0.5)
!
!
      rdist = sqrt(distx*distx + disty*disty + distz*distz)
      tempr = fcut(rdist, radius, radius+0.1)
      rhoR = tempr
      rhoB = 1.0 - tempr

      ! distx = i - (nx/2 + 0.5)
      ! disty = j - (ny/2 + 0.5)
      ! distz = k - (nz/4 + 0.5)
      ! rdist = sqrt(distx*distx + disty*disty + distz*distz)
      ! tempr = fcut(rdist, radius, radius+0.1)
      ! rhoR = rhoR + 0.0 + (1.0 - 0.0) * tempr
      ! rhoB = rhoB + 1.0 + (0.0 - 1.0) * tempr

      ! distx = i - (nx/2 + 0.5)
      ! disty = j - (ny/2 + 0.5)
      ! distz = k - (3*nz/4 + 0.5)
      ! rdist = sqrt(distx*distx + disty*disty + distz*distz)
      ! tempr = fcut(rdist, radius, radius+0.1)
      ! rhoR = rhoR + 0.0 + (1.0 - 0.0) * tempr
      ! rhoB = rhoB + 1.0 + (0.0 - 1.0) * tempr

      ! rhoR = 1.0
      ! rhoB = 0.0

      u = vx
      v = vy
      w = vz
      ! write(*,*) 'CUDA setup2',rho,i,j,k
  
      rhoR_d(i,j,k) = rhoR
      rhoB_d(i,j,k) = rhoB
      do l = 0, npops-1
	      eqR = equil(rhoR, u,v,w, l)
        popsR_d(i,j,k, l, 1) = eqR
	      eqB = equil(rhoB, u,v,w, l)
        popsB_d(i,j,k, l, 1) = eqB

        ! Clears other stuff
        popsR_d(i,j,k, l, 2) = 0.0
        popsB_d(i,j,k, l, 2) = 0.0
      end do

      myfluid_d(i,j,k, 1) = fluid_fluid
      myfluid_d(i,j,k, 2) = fluid_fluid
      debugfluid_d(i,j,k) = 0

      countmk_d = 0
      countrm_d = 0
      partVol_d = 0
      oldpartVol_d = 0
      countn2p_d = 0
    end subroutine setup2

#ifdef BGK
    ! Compute forces on lattice
    attributes(global) subroutine lb_force()
      integer :: i,j,k, l
  
      i = (blockIdx%x-1) * TILE_DIMx + threadIdx%x
      j = (blockIdx%y-1) * TILE_DIMy + threadIdx%y
      k = (blockIdx%z-1) * TILE_DIMz + threadIdx%z

      force_d(1, i,j,k) = 0.0
      force_d(2, i,j,k) = 0.0
      force_d(3, i,j,k) = 0.0
    end subroutine


    ! Time Step
    attributes(global) subroutine time_step(step, flip, omega,oneminusomega)
      integer, value :: step,flip
      real, value :: omega,oneminusomega
      real    :: rho,invrho, u,v,w
      integer :: i,j,k, l, flop
      integer :: i1,j1,k1
  
      i = (blockIdx%x-1) * TILE_DIMx + threadIdx%x
      j = (blockIdx%y-1) * TILE_DIMy + threadIdx%y
      k = (blockIdx%z-1) * TILE_DIMz + threadIdx%z
      ! if (step==1 .and. 1==i*j*k) write(*,*) 'CUDA time_step] i,k:',i,j,k

      rho = compute_rho(popsR_d,i,j,k,flip)
      if (rho < 1.0E-7) then
       write(*,*) 'Rho error:',rho,i,j,k
       stop_d = __LINE__
      endif

      invrho = 1.0 / rho
      u   = compute_u_1fl(popsR_d,i,j,k,flip, invrho)
      v   = compute_v_1fl(popsR_d,i,j,k,flip, invrho)
      w   = compute_w_1fl(popsR_d,i,j,k,flip, invrho)
  
      flop = 3 - flip
      do l = 0, npops-1
        i1 = i + ex_d(l)
        j1 = j + ey_d(l)
        k1 = k + ez_d(l)
        popsR_d(i1,j1,k1, l, flop) = popsR_d(i,j,k, l, flip)*oneminusomega + equil(rho, u,v,w, l)*omega
      end do
    end subroutine time_step

    attributes(global) subroutine time_step_force_cost(step, flip, omega,oneminusomega)
      integer, value :: step,flip
      real, value :: omega,oneminusomega
      real    :: rho,invrho, u,v,w, fx,fy,fz
      real    :: oldflu,feq,feqshift
      integer :: i,j,k, l, flop
      integer :: i1,j1,k1
  
      i = (blockIdx%x-1) * TILE_DIMx + threadIdx%x
      j = (blockIdx%y-1) * TILE_DIMy + threadIdx%y
      k = (blockIdx%z-1) * TILE_DIMz + threadIdx%z
      ! if (1==step.and.1==i*j*k) write(*,*) 'CUDA time_step_force_cost] i,k:',i,j,k

      rho = compute_rho(popsR_d,i,j,k,flip)
      if (rho < 1.0E-7) then
       write(*,*) 'Rho error:',rho,i,j,k
       stop_d = __LINE__
      endif

      invrho = 1.0 / rho
      u   = compute_u_1fl(popsR_d,i,j,k,flip, invrho)
      v   = compute_v_1fl(popsR_d,i,j,k,flip, invrho)
      w   = compute_w_1fl(popsR_d,i,j,k,flip, invrho)

      fx = fx_d * invrho
      fy = fy_d * invrho
      fz = fz_d * invrho
      if (abs(fx) > 5.0E-1 .or. abs(fy) > 5.0E-1 .or. abs(fz) > 5.0E-1) then
       write(*,*) 'Big fx,fy,fz:',fx,fy,fz
       stop_d = __LINE__
      endif
  
      flop = 3 - flip
      do l = 0, npops-1
        i1 = i + ex_d(l)
        j1 = j + ey_d(l)
        k1 = k + ez_d(l)
      
        !!!!!
        ! THIS is not like Krueger...same as ML
        !!!!!
        oldflu   = popsR_d(i,j,k, l, flip)
        feq      = equil(rho, u,   v,   w, l)
        feqshift = equil(rho, u+fx,v+fy,w+fz, l)

        popsR_d(i1,j1,k1, l, flop) = oldflu*oneminusomega  - feq*oneminusomega + feqshift
      end do
    end subroutine time_step_force_cost

    attributes(global) subroutine time_step_force(step, flip, omega,oneminusomega)
      integer, value :: step,flip
      real, value :: omega,oneminusomega
      real    :: rho,invrho, u,v,w, fx,fy,fz
      real    :: oldflu,feq,feqshift
      integer :: i,j,k, l, flop
      integer :: i1,j1,k1
  
      i = (blockIdx%x-1) * TILE_DIMx + threadIdx%x
      j = (blockIdx%y-1) * TILE_DIMy + threadIdx%y
      k = (blockIdx%z-1) * TILE_DIMz + threadIdx%z
      ! if (1==step.and.1==i*j*k) write(*,*) 'CUDA time_step_force] i,k:',i,j,k

      rho = compute_rho(popsR_d,i,j,k,flip)
      if (rho < 1.0E-7) then
       write(*,*) 'Rho error:',rho,i,j,k
       stop_d = __LINE__
      endif

      invrho = 1.0 / rho
      u   = compute_u_1fl(popsR_d,i,j,k,flip, invrho)
      v   = compute_v_1fl(popsR_d,i,j,k,flip, invrho)
      w   = compute_w_1fl(popsR_d,i,j,k,flip, invrho)

      fx = force_d(1, i,j,k) * invrho
      fy = force_d(2, i,j,k) * invrho
      fz = force_d(3, i,j,k) * invrho
      if (abs(fx) > 5.0E-1 .or. abs(fy) > 5.0E-1 .or. abs(fz) > 5.0E-1) then
       write(*,*) 'Big fx,fy,fz:',fx,fy,fz
       stop_d = __LINE__
      endif
  
      flop = 3 - flip
      do l = 0, npops-1
        i1 = i + ex_d(l)
        j1 = j + ey_d(l)
        k1 = k + ez_d(l)
      
        !!!!!
        ! THIS is not like Krueger...same as ML
        !!!!!
        oldflu   = popsR_d(i,j,k, l, flip)
        feq      = equil(rho, u,   v,   w, l)
        feqshift = equil(rho, u+fx,v+fy,w+fz, l)
        popsR_d(i1,j1,k1, l, flop) = oldflu*oneminusomega - feq*oneminusomega + feqshift
      end do
    end subroutine time_step_force

    attributes(global) subroutine init_rho_isfluid_BGK(step, flip)
    integer, value :: step,flip
    real    :: rhoR
    integer :: i,j,k, l

    i = (blockIdx%x-1) * TILE_DIMx + threadIdx%x
    j = (blockIdx%y-1) * TILE_DIMy + threadIdx%y
    k = (blockIdx%z-1) * TILE_DIMz + threadIdx%z
    ! if (step==1 .and. 1==i*j*k) write(*,*) 'CUDA init_rho_isfluid_BGK] i,k:',i,j,k

    ! Only on fluid nodes
    if (myfluid_d(i,j,k, flip) == fluid_fluid) then
      rhoR = compute_rho(popsR_d,i,j,k,flip)

      if (rhoR<minRho .or. rhoR>10) then
        ! write(*,*) 'init_rho_isfluid_BGK]Range error rhoR', step, linear(i,j,k), rhoR
        stop_d = __LINE__
      endif

      rhoR_d(i,j,k) = rhoR
    else
      rhoR_d(i,j,k) = MINDENS
    endif
    end subroutine init_rho_isfluid_BGK


    attributes(global) subroutine time_step_BGK(step, flip, omega,oneminusomega)
      integer, value :: step,flip
      real, value :: omega,oneminusomega
      real    :: rhoR, invrho, u,v,w  
      integer :: i,j,k, l
      
  
      i = (blockIdx%x-1) * TILE_DIMx + threadIdx%x
      j = (blockIdx%y-1) * TILE_DIMy + threadIdx%y
      k = (blockIdx%z-1) * TILE_DIMz + threadIdx%z
      ! if (step==1 .and. 1==i*j*k) write(*,*) 'CUDA time_step_CG] i,k:',i,j,k

      if (myfluid_d(i,j,k, flip) == fluid_fluid) then
        rhoR = rhoR_d(i,j,k)

        invrho = 1.0 / rhoR
        u   = compute_u_1fl(popsR_d,i,j,k,flip, invrho)
        v   = compute_v_1fl(popsR_d,i,j,k,flip, invrho)
        w   = compute_w_1fl(popsR_d,i,j,k,flip, invrho)

        !bgk step
        do l = 0, npops-1
          popsR_d(i,j,k,l, flip) = popsR_d(i,j,k, l, flip)*oneminusomega + equil(rhoR,u,v,w, l)*omega
        enddo
      endif
    end subroutine time_step_BGK

    attributes(global) subroutine copy_BGK(step, flip)
      integer, value :: step,flip
      integer :: i,j,k, l, flop

      i = (blockIdx%x-1) * TILE_DIMx + threadIdx%x
      j = (blockIdx%y-1) * TILE_DIMy + threadIdx%y
      k = (blockIdx%z-1) * TILE_DIMz + threadIdx%z
      ! if (step==1 .and. 1==i*j*k) write(*,*) 'CUDA copy_BGK] i,k:',i,j,k

      flop = 3 - flip
      
      do l = 0, npops-1
        popsR_d(i,j,k,l, flop) = popsR_d(i,j,k,l, flip)
      enddo
    end subroutine copy_BGK


    attributes(global) subroutine stream_BGK(step, flip)
      integer, value :: step,flip
      integer :: i,j,k, l, flop
      integer :: i1,j1,k1


      i = (blockIdx%x-1) * TILE_DIMx + threadIdx%x
      j = (blockIdx%y-1) * TILE_DIMy + threadIdx%y
      k = (blockIdx%z-1) * TILE_DIMz + threadIdx%z
      ! if (step==1 .and. 1==i*j*k) write(*,*) 'CUDA stream_BGK] i,k:',i,j,k

      flop = 3 - flip

      ! Streaming      
      if (myfluid_d(i,j,k, flip) /= fluid_spheredead) then
        do l = 1, npops-1
          i1 = i + ex_d(l)
          j1 = j + ey_d(l)
          k1 = k + ez_d(l)
          popsR_d(i1,j1,k1,l, flop) = popsR_d(i,j,k,l, flip)
        enddo
      endif    
    end subroutine stream_BGK

    attributes(global) subroutine stream_BGK_x(step, flip)
      integer, value :: step,flip
      integer :: i,j,k, l, flop
      integer :: i1,j1,k1
  
      j = (blockIdx%x-1) * TILE_DIM + threadIdx%x - 1
      k = (blockIdx%y-1) * TILE_DIM + threadIdx%y - 1

      if (j>ny+1) return
      if (k>nz+1) return

      flop = 3 - flip

      ! Stream x=0
      i = 0
      if (myfluid_d(i,j,k, flip) /= fluid_spheredead) then
        do l = 1, npops-1
          i1 = i + ex_d(l)
          j1 = j + ey_d(l)
          k1 = k + ez_d(l)
          if (1<=i1 .and. i1<=nx .and. 1<=j1 .and. j1<=ny .and. 1<=k1 .and. k1<=nz) then
            popsR_d(i1,j1,k1,l, flop) = popsR_d(i,j,k,l, flip)
          endif
        end do
      endif

      ! Stream x=nx+1
      i = nx+1
      if (myfluid_d(i,j,k, flip) /= fluid_spheredead) then
        do l = 1, npops-1
          i1 = i + ex_d(l)
          j1 = j + ey_d(l)
          k1 = k + ez_d(l)
          if (1<=i1 .and. i1<=nx .and. 1<=j1 .and. j1<=ny .and. 1<=k1 .and. k1<=nz) then
            popsR_d(i1,j1,k1,l, flop) = popsR_d(i,j,k,l, flip)
          endif
        end do
      endif
    end subroutine stream_BGK_x

    attributes(global) subroutine stream_BGK_y(step, flip)
    integer, value :: step,flip
    integer :: i,j,k, l, flop
    integer :: i1,j1,k1

    i = (blockIdx%x-1) * TILE_DIM + threadIdx%x - 1
    k = (blockIdx%y-1) * TILE_DIM + threadIdx%y - 1
    
    if (i>nx+1) return
    if (k>nz+1) return

    flop = 3 - flip

    ! Stream y=0
    j = 0
    if (myfluid_d(i,j,k, flip) /= fluid_spheredead) then
      do l = 1, npops-1
        i1 = i + ex_d(l)
        j1 = j + ey_d(l)
        k1 = k + ez_d(l)
        if (1<=i1 .and. i1<=nx .and. 1<=j1 .and. j1<=ny .and. 1<=k1 .and. k1<=nz) then
          popsR_d(i1,j1,k1,l, flop) = popsR_d(i,j,k,l, flip)
        endif
      end do
    endif

    ! Stream y=ny+1
    j = ny+1
    if (myfluid_d(i,j,k, flip) /= fluid_spheredead) then
      do l = 1, npops-1
        i1 = i + ex_d(l)
        j1 = j + ey_d(l)
        k1 = k + ez_d(l)
        if (1<=i1 .and. i1<=nx .and. 1<=j1 .and. j1<=ny .and. 1<=k1 .and. k1<=nz) then
          popsR_d(i1,j1,k1,l, flop) = popsR_d(i,j,k,l, flip)
        endif
      end do
    endif
  end subroutine stream_BGK_y

  attributes(global) subroutine stream_BGK_z(step, flip)
    integer, value :: step,flip
    integer :: i,j,k, l, flop
    integer :: i1,j1,k1

    i = (blockIdx%x-1) * TILE_DIM + threadIdx%x - 1
    j = (blockIdx%y-1) * TILE_DIM + threadIdx%y - 1
    
    if (i>nx+1) return
    if (j>ny+1) return

    flop = 3 - flip

    ! Stream z=0
    k = 0
    if (myfluid_d(i,j,k, flip) /= fluid_spheredead) then
      do l = 1, npops-1
        i1 = i + ex_d(l)
        j1 = j + ey_d(l)
        k1 = k + ez_d(l)
        if (1<=i1 .and. i1<=nx .and. 1<=j1 .and. j1<=ny .and. 1<=k1 .and. k1<=nz) then
          popsR_d(i1,j1,k1,l, flop) = popsR_d(i,j,k,l, flip)
        endif
      end do
    endif

    ! Stream z=nz+1
    k = nz+1
    if (myfluid_d(i,j,k, flip) /= fluid_spheredead) then
      do l = 1, npops-1
        i1 = i + ex_d(l)
        j1 = j + ey_d(l)
        k1 = k + ez_d(l)
        if (1<=i1 .and. i1<=nx .and. 1<=j1 .and. j1<=ny .and. 1<=k1 .and. k1<=nz) then
          popsR_d(i1,j1,k1,l, flop) = popsR_d(i,j,k,l, flip)
        endif
      end do
    endif
  end subroutine stream_BGK_z    
#endif
#ifdef CG
    !!!!!!!!!!!!!!!!!!! Color gradient !!!!!!!!!!!!!!!!!!!

    attributes(global) subroutine init_rho_CG(step, flip)
      integer, value :: step,flip
      real    :: rhoR,rhoB
      integer :: i,j,k
  
      i = (blockIdx%x-1) * TILE_DIMx + threadIdx%x
      j = (blockIdx%y-1) * TILE_DIMy + threadIdx%y
      k = (blockIdx%z-1) * TILE_DIMz + threadIdx%z

      ! Only on fluid nodes
      if (myfluid_d(i,j,k, flip) == fluid_fluid) then
        rhoR = compute_rho(popsR_d,i,j,k,flip)
        rhoB = compute_rho(popsB_d,i,j,k,flip)

        if (rhoR<minRho .or. rhoR>10) then
          write(*,*) 'init_rho_CG]Range error rhoR', step, linear(i,j,k), rhoR
          stop_d = __LINE__
        endif
        if (rhoB<minRho .or. rhoB>10) then
          write(*,*) 'init_rho_CG]Range error rhoB', step, linear(i,j,k), rhoB
          stop_d = __LINE__
        endif

        rhoR_d(i,j,k) = rhoR
        rhoB_d(i,j,k) = rhoB
      else
        rhoR_d(i,j,k) = MINDENS
        rhoB_d(i,j,k) = MINDENS
      endif
    end subroutine init_rho_CG


    
    

    attributes(global) subroutine time_step_CG(step, flip)
      integer, value :: step,flip
      real    :: rhoR,rhoB,rhosum,invrho, u,v,w
      real    :: rhoavg,omega,oneminusomega
      real    :: rhoR_shifted,rhoB_shifted,rhosum_shifted
!      real    :: grad_rhoRx,grad_rhoRy,grad_rhoRz, grad_rhoBx,grad_rhoBy,grad_rhoBz
      real    :: psi_shifted
      real    :: psix,psiy,psiz,psinorm_sq,psinorm,acoeff,e_dot_psi
      real    :: temp,temp1, cosphi, feq
      real, parameter :: mylimit=1.e-20
      real    :: tempR(0:npops-1), tempB(0:npops-1), fdum(0:npops-1)

      integer :: i,j,k, i1,j1,k1,l
      
  
      i = (blockIdx%x-1) * TILE_DIMx + threadIdx%x
      j = (blockIdx%y-1) * TILE_DIMy + threadIdx%y
      k = (blockIdx%z-1) * TILE_DIMz + threadIdx%z
      ! if (step==1 .and. 1==i*j*k) write(*,*) 'CUDA time_step_CG] i,k:',i,j,k

      if (myfluid_d(i,j,k, flip) == fluid_fluid) then
        rhoR = rhoR_d(i,j,k)
        rhoB = rhoB_d(i,j,k)
        rhosum = rhoR + rhoB

        rhoavg = rhoR/rhosum*viscR + rhoB/rhosum*viscB
        omega  = 1.0 / ( rhoavg/cssq  + 0.5)
        oneminusomega = 1.0 - omega

        invrho = 1.0 / rhosum
        u   = compute_u_1fl(popsR_d,i,j,k,flip, invrho) + compute_u_1fl(popsB_d,i,j,k,flip, invrho)
        v   = compute_v_1fl(popsR_d,i,j,k,flip, invrho) + compute_v_1fl(popsB_d,i,j,k,flip, invrho)
        w   = compute_w_1fl(popsR_d,i,j,k,flip, invrho) + compute_w_1fl(popsB_d,i,j,k,flip, invrho)


        !bgk step
        do l = 0, npops-1
            tempR(l) = popsR_d(i,j,k, l, flip)*oneminusomega + equil(rhoR,u,v,w, l)*omega
        enddo

        do l = 0, npops-1
            tempB(l) = popsB_d(i,j,k, l, flip)*oneminusomega + equil(rhoB,u,v,w, l)*omega
        enddo


        ! Psi calc
        psix = ZERO
        psiy = ZERO
        psiz = ZERO
        do l = 1, npops-1
          i1 = mod(i + ex_d(l) +nx-1, nx) + 1
          j1 = mod(j + ey_d(l) +ny-1, ny) + 1
          k1 = mod(k + ez_d(l) +nz-1, nz) + 1
          if (i1<1 .or. i1>nx .or. j1<1 .or. j1>ny .or.k1<1 .or. k1>nz) then
            stop_d = __LINE__
          endif

          rhoR_shifted = rhoR_d(i1,j1,k1)
          rhoB_shifted = rhoB_d(i1,j1,k1)
          psi_shifted = (rhoR_shifted - rhoB_shifted) / (rhoR_shifted + rhoB_shifted)
          psix = psix + a_d(l)*ex_d(l)* psi_shifted
          psiy = psiy + a_d(l)*ey_d(l)* psi_shifted
          psiz = psiz + a_d(l)*ez_d(l)* psi_shifted
        enddo

        !perturbation step
        psinorm_sq = psix*psix + psiy*psiy + psiz*psiz
        if (psinorm_sq>mylimit) then
          psinorm = sqrt(psinorm_sq)
          acoeff =  NINE/FOUR * omega * sigma_cg

          do l = 0, npops-1
              e_dot_psi = ex_d(l)*psix + ey_d(l)*psiy + ez_d(l)*psiz
              temp = psinorm*(p_d(l)*(e_dot_psi*e_dot_psi)/psinorm_sq - b_l_d(l))
              !if(isnan(temp)) temp=ZERO

              fdum(l) = tempR(l) + tempB(l) + acoeff*temp
          enddo

          !recoloring step
          do l=0, npops-1
              feq = equil(rhoR,ZERO,ZERO,ZERO, l) + equil(rhoB,ZERO,ZERO,ZERO, l)
              e_dot_psi = ex_d(l)*psix + ey_d(l)*psiy + ez_d(l)*psiz
              temp1 = rec_fact_d(l) * psinorm

              if (temp1<=mylimit) then
                cosphi = ZERO
              else
                cosphi = e_dot_psi/temp1
              endif

              temp = beta_CG * rhoR * rhoB * cosphi/(rhosum*rhosum)

              tempR(l) = fdum(l)*rhoR/rhosum + temp*feq
              tempB(l) = fdum(l)*rhoB/rhosum - temp*feq
          enddo
        endif

        ! Store to mem
        do l = 0, npops-1
          popsR_d(i,j,k,l, flip) = tempR(l)
        enddo

        do l = 0, npops-1
          popsB_d(i,j,k,l, flip) = tempB(l)
        enddo
        
      endif
    end subroutine time_step_CG


    attributes(global) subroutine copy_CG(step, flip)
      integer, value :: step,flip
      integer :: i,j,k, l, flop

      i = (blockIdx%x-1) * TILE_DIMx + threadIdx%x
      j = (blockIdx%y-1) * TILE_DIMy + threadIdx%y
      k = (blockIdx%z-1) * TILE_DIMz + threadIdx%z
      ! if (step==1 .and. 1==i*j*k) write(*,*) 'CUDA copy_CG] i,k:',i,j,k

      flop = 3 - flip
      
      do l = 0, npops-1
        popsR_d(i,j,k,l, flop) = popsR_d(i,j,k,l, flip)
        popsB_d(i,j,k,l, flop) = popsB_d(i,j,k,l, flip)
      enddo
    end subroutine copy_CG


    attributes(global) subroutine stream_CG(step, flip)
      integer, value :: step,flip
      integer :: i,j,k, l, flop
      integer :: i1,j1,k1
      integer :: atm_i,atm_j,atm_k, atm_st,atm_en, i_atm,i_list


      i = (blockIdx%x-1) * TILE_DIMx + threadIdx%x
      j = (blockIdx%y-1) * TILE_DIMy + threadIdx%y
      k = (blockIdx%z-1) * TILE_DIMz + threadIdx%z
      ! if (step==1 .and. 1==i*j*k) write(*,*) 'CUDA stream_CG] i,k:',i,j,k

      flop = 3 - flip


      ! Streaming      
      if (myfluid_d(i,j,k, flip) /= fluid_spheredead) then
        do l = 1, npops-1
          i1 = i + ex_d(l)
          j1 = j + ey_d(l)
          k1 = k + ez_d(l)
          popsR_d(i1,j1,k1,l, flop) = popsR_d(i,j,k,l, flip)
        enddo
    
        do l = 1, npops-1
          i1 = i + ex_d(l)
          j1 = j + ey_d(l)
          k1 = k + ez_d(l)
          popsB_d(i1,j1,k1,l, flop) = popsB_d(i,j,k,l, flip)
        enddo
      endif


    end subroutine stream_CG

    attributes(global) subroutine stream_CG_x(step, flip)
      integer, value :: step,flip
      integer :: i,j,k, l, flop
      integer :: i1,j1,k1
  
      j = (blockIdx%x-1) * TILE_DIM + threadIdx%x - 1
      k = (blockIdx%y-1) * TILE_DIM + threadIdx%y - 1

      if (j>ny+1) return
      if (k>nz+1) return

      flop = 3 - flip

      ! Stream x=0
      i = 0
      if (myfluid_d(i,j,k, flip) /= fluid_spheredead) then
        do l = 1, npops-1
          i1 = i + ex_d(l)
          j1 = j + ey_d(l)
          k1 = k + ez_d(l)
          if (1<=i1 .and. i1<=nx .and. 1<=j1 .and. j1<=ny .and. 1<=k1 .and. k1<=nz) then
            popsR_d(i1,j1,k1,l, flop) = popsR_d(i,j,k,l, flip)
            popsB_d(i1,j1,k1,l, flop) = popsB_d(i,j,k,l, flip)
          endif
        end do
      endif

      ! Stream x=nx+1
      i = nx+1
      if (myfluid_d(i,j,k, flip) /= fluid_spheredead) then
        do l = 1, npops-1
          i1 = i + ex_d(l)
          j1 = j + ey_d(l)
          k1 = k + ez_d(l)
          if (1<=i1 .and. i1<=nx .and. 1<=j1 .and. j1<=ny .and. 1<=k1 .and. k1<=nz) then
            popsR_d(i1,j1,k1,l, flop) = popsR_d(i,j,k,l, flip)
            popsB_d(i1,j1,k1,l, flop) = popsB_d(i,j,k,l, flip)
          endif
        end do
      endif
    end subroutine stream_CG_x

    attributes(global) subroutine stream_CG_y(step, flip)
    integer, value :: step,flip
    integer :: i,j,k, l, flop
    integer :: i1,j1,k1

    i = (blockIdx%x-1) * TILE_DIM + threadIdx%x - 1
    k = (blockIdx%y-1) * TILE_DIM + threadIdx%y - 1
    
    if (i>nx+1) return
    if (k>nz+1) return

    flop = 3 - flip

    ! Stream y=0
    j = 0
    if (myfluid_d(i,j,k, flip) /= fluid_spheredead) then
      do l = 1, npops-1
        i1 = i + ex_d(l)
        j1 = j + ey_d(l)
        k1 = k + ez_d(l)
        if (1<=i1 .and. i1<=nx .and. 1<=j1 .and. j1<=ny .and. 1<=k1 .and. k1<=nz) then
          popsR_d(i1,j1,k1,l, flop) = popsR_d(i,j,k,l, flip)
          popsB_d(i1,j1,k1,l, flop) = popsB_d(i,j,k,l, flip)
        endif
      end do
    endif

    ! Stream y=ny+1
    j = ny+1
    if (myfluid_d(i,j,k, flip) /= fluid_spheredead) then
      do l = 1, npops-1
        i1 = i + ex_d(l)
        j1 = j + ey_d(l)
        k1 = k + ez_d(l)
        if (1<=i1 .and. i1<=nx .and. 1<=j1 .and. j1<=ny .and. 1<=k1 .and. k1<=nz) then
          popsR_d(i1,j1,k1,l, flop) = popsR_d(i,j,k,l, flip)
          popsB_d(i1,j1,k1,l, flop) = popsB_d(i,j,k,l, flip)
        endif
      end do
    endif
  end subroutine stream_CG_y

  attributes(global) subroutine stream_CG_z(step, flip)
    integer, value :: step,flip
    integer :: i,j,k, l, flop
    integer :: i1,j1,k1

    i = (blockIdx%x-1) * TILE_DIM + threadIdx%x - 1
    j = (blockIdx%y-1) * TILE_DIM + threadIdx%y - 1
    
    if (i>nx+1) return
    if (j>ny+1) return

    flop = 3 - flip

    ! Stream z=0
    k = 0
    if (myfluid_d(i,j,k, flip) /= fluid_spheredead) then
      do l = 1, npops-1
        i1 = i + ex_d(l)
        j1 = j + ey_d(l)
        k1 = k + ez_d(l)
        if (1<=i1 .and. i1<=nx .and. 1<=j1 .and. j1<=ny .and. 1<=k1 .and. k1<=nz) then
          popsR_d(i1,j1,k1,l, flop) = popsR_d(i,j,k,l, flip)
          popsB_d(i1,j1,k1,l, flop) = popsB_d(i,j,k,l, flip)
        endif
      end do
    endif

    ! Stream z=nz+1
    k = nz+1
    if (myfluid_d(i,j,k, flip) /= fluid_spheredead) then
      do l = 1, npops-1
        i1 = i + ex_d(l)
        j1 = j + ey_d(l)
        k1 = k + ez_d(l)
        if (1<=i1 .and. i1<=nx .and. 1<=j1 .and. j1<=ny .and. 1<=k1 .and. k1<=nz) then
          popsR_d(i1,j1,k1,l, flop) = popsR_d(i,j,k,l, flip)
          popsB_d(i1,j1,k1,l, flop) = popsB_d(i,j,k,l, flip)
        endif
      end do
    endif
  end subroutine stream_CG_z
#endif
    
  end module kernels_fluid_subs
